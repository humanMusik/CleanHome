package com.humanmusik.cleanhome.data

import android.content.Context
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import com.humanmusik.cleanhome.data.entities.ResidentEntity
import com.humanmusik.cleanhome.data.entities.RoomEntity
import com.humanmusik.cleanhome.data.entities.TaskEntity
import com.humanmusik.cleanhome.data.repository.CleanHomeRepositoryImpl
import com.humanmusik.cleanhome.domain.TaskFilter
import com.humanmusik.cleanhome.domain.model.Resident
import com.humanmusik.cleanhome.domain.model.task.Frequency
import com.humanmusik.cleanhome.domain.model.task.Task
import com.humanmusik.cleanhome.domain.model.task.Urgency
import com.humanmusik.cleanhome.utilstest.assertContainsExactlyElementsIn
import com.humanmusik.cleanhome.utilstest.assertIsEqualTo
import com.humanmusik.cleanhome.utilstest.runCancellingTest
import com.humanmusik.cleanhome.utilstest.test
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.test.TestScope
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.extension.ExtendWith
import tech.apter.junit.jupiter.robolectric.RobolectricExtension
import java.time.LocalDate
import java.time.Duration
import java.time.Duration.Companion.minutes

@ExtendWith(RobolectricExtension::class)
class CleanHomeRepositoryImplTest {
    private lateinit var cleanHomeDao: CleanHomeDao
    private lateinit var db: CleanHomeDatabase

    @BeforeEach
    fun createDb() {
        val context = ApplicationProvider.getApplicationContext<Context>()
        db = Room.inMemoryDatabaseBuilder(
            context, CleanHomeDatabase::class.java
        )
            .allowMainThreadQueries()
            .build()

        cleanHomeDao = db.cleanHomeDao()
    }

    @AfterEach
    fun closeDb() {
        db.close()
    }

    @Test
    fun `test task CRUD operations`() {
        runCancellingTest {
            var taskId: Int? = null

            val createdTask = Task(
                // id is auto-generated by room
                id = taskId,
                name = "Vacuum",
                room = com.humanmusik.cleanhome.domain.model.Room(
                    id = 1,
                    name = "My Bedroom",
                    homeId = 1,
                ),
                duration = 10.minutes,
                frequency = Frequency.Weekly,
                scheduledDate = LocalDate.of(2025, 10, 10),
                urgency = Urgency.NonUrgent,
                assigneeId = Resident(
                    id = 1,
                    name = "Me",
                    homeId = 1,
                ),
            )

            // GIVEN a cleanHomeRepository
            val cleanHomeRepository = createCleanHomeRepository(this@runCancellingTest)

            cleanHomeRepository
                .flowOfTasks(filter = TaskFilter.All)
                .test {
                    // WHEN createTask is called
                    cleanHomeRepository.createTask(createdTask)

                    // THEN created task exists in DB
                    createdTask.assertExistsInDb(awaitItem()) {
                        taskId = toList()[it].id
                    }

                    val updatedTask = Task(
                        // id is the same as the previously created task
                        id = taskId,
                        name = "Vacuum",
                        room = com.humanmusik.cleanhome.domain.model.Room(
                            id = 1,
                            name = "My Bedroom",
                            homeId = 1,
                        ),
                        duration = 30.minutes,
                        frequency = Frequency.Fortnightly,
                        scheduledDate = LocalDate.of(2025, 10, 15),
                        urgency = Urgency.NonUrgent,
                        assigneeId = Resident(
                            id = 1,
                            name = "You",
                            homeId = 1,
                        ),
                    )

                    // WHEN updateTask is called
                    cleanHomeRepository.updateTask(updatedTask)

                    // THEN the updated task exists in the DB
                    updatedTask.assertExistsInDb(awaitItem())
                }
        }
    }

    //region flowOfTasks

    @Test
    fun `flowOfTasks - returns all tasks when filtering by ALL`() {
        runCancellingTest {
            val taskEntities = listOf(
                taskEntity(id = 1),
                taskEntity(id = 2),
                taskEntity(id = 3),
                taskEntity(id = 4),
            )

            val expectedTasks = listOf(
                task(id = 1),
                task(id = 2),
                task(id = 3),
                task(id = 4),
            )

            val cleanHomeRepository = createCleanHomeRepository()

            // GIVEN db contains a list of task entities
            cleanHomeDao.deleteAndInsertTasks(taskEntities)

            cleanHomeRepository
                // WHEN flowOfTasks is called with ALL filter
                .flowOfTasks(filter = TaskFilter.All)
                .test {
                    // THEN return all tasks in db
                    awaitItem().assertContainsExactlyElementsIn(expectedTasks)
                }
        }
    }

    @Test
    fun `flowOfTasks - returns tasks with specified id when filtering by id`() {
        runCancellingTest {
            val taskEntities = listOf(
                taskEntity(id = 1),
                taskEntity(id = 2),
                taskEntity(id = 3),
                taskEntity(id = 4),
            )

            val filterByIds = setOf(1, 3)

            val expectedTasks = listOf(
                task(id = 1),
                task(id = 3),
            )

            val cleanHomeRepository = createCleanHomeRepository()

            // GIVEN db contains a list of task entities
            cleanHomeDao.deleteAndInsertTasks(taskEntities)

            cleanHomeRepository
                // WHEN flowOfTasks is called with ALL filter
                .flowOfTasks(filter = TaskFilter.ById(ids = filterByIds))
                .test {
                    // THEN return all tasks in db
                    awaitItem().assertContainsExactlyElementsIn(expectedTasks)
                }
        }
    }

    @Test
    fun `flowOfTasks - returns tasks with specified assignedTo when filtering by assignedTo`() {
        runCancellingTest {
            val taskEntities = listOf(
                taskEntity(id = 1, assignedTo = ResidentEntity(1, "Leslie", 1)),
                taskEntity(id = 2, assignedTo = ResidentEntity(1, "Leslie", 1)),
                taskEntity(id = 3, assignedTo = ResidentEntity(2, "Jennifer", 1)),
                taskEntity(id = 4, assignedTo = ResidentEntity(3, "Cihan", 1)),
            )

            val filterByResidents = setOf(
                Resident(2, "Jennifer", 1),
                Resident(3, "Cihan", 1),
            )

            val expectedTasks = listOf(
                task(id = 3, assignedTo = Resident(2, "Jennifer", 1)),
                task(id = 4, assignedTo = Resident(3, "Cihan", 1)),
            )

            val cleanHomeRepository = createCleanHomeRepository()

            // GIVEN db contains a list of task entities
            cleanHomeDao.deleteAndInsertTasks(taskEntities)

            cleanHomeRepository
                // WHEN flowOfTasks is called with ALL filter
                .flowOfTasks(filter = TaskFilter.ByAssignment(residents = filterByResidents))
                .test {
                    // THEN return all tasks in db
                    awaitItem().assertContainsExactlyElementsIn(expectedTasks)
                }
        }
    }

    @Test
    fun `flowOfTasks - returns tasks that are between dates when filtering by ByScheduledDate`() {
        runCancellingTest {
            val taskEntities = listOf(
                taskEntity(id = 1, scheduledDate = LocalDate.of(2025, 8, 11)),
                taskEntity(id = 2, scheduledDate = LocalDate.of(2025, 8, 1)),
                taskEntity(id = 3, scheduledDate = LocalDate.of(2025, 10, 27)),
                taskEntity(id = 4, scheduledDate = LocalDate.of(2026, 3, 2)),
                taskEntity(id = 5, scheduledDate = LocalDate.of(2023, 1, 1)),
                taskEntity(id = 6, scheduledDate = LocalDate.of(2025, 5, 3)),
                taskEntity(id = 7, scheduledDate = LocalDate.of(2024, 9, 14)),
                taskEntity(id = 8, scheduledDate = LocalDate.of(2025, 9, 1)),
            )

            val startDate = LocalDate.of(2025, 7, 1)
            val endDate = LocalDate.of(2025, 9, 1)


            val expectedTasks = listOf(
                task(id = 1, scheduledDate = LocalDate.of(2025, 8, 11)),
                task(id = 2, scheduledDate = LocalDate.of(2025, 8, 1)),
                task(id = 8, scheduledDate = LocalDate.of(2025, 9, 1)),
            )

            val cleanHomeRepository = createCleanHomeRepository()

            // GIVEN db contains a list of task entities
            cleanHomeDao.deleteAndInsertTasks(taskEntities)

            cleanHomeRepository
                // WHEN flowOfTasks is called with ALL filter
                .flowOfTasks(
                    filter = TaskFilter.ByScheduledDate(
                        startDateInclusive = startDate,
                        endDateInclusive = endDate,
                    )
                )
                .test {
                    // THEN return all tasks in db
                    awaitItem().assertContainsExactlyElementsIn(expectedTasks)
                }
        }
    }

    //endregion

    @Test
    fun `flowOfAllRooms() - returns all rooms`() {
        runCancellingTest {
            val roomEntities = listOf(
                RoomEntity(0, "My Bedroom", 1),
                RoomEntity(0, "Living Room", 1),
                RoomEntity(0, "Bathroom", 1),
            )

            val expectedRooms = listOf(
                com.humanmusik.cleanhome.domain.model.Room(1, "My Bedroom", 1),
                com.humanmusik.cleanhome.domain.model.Room(2, "Living Room", 1),
                com.humanmusik.cleanhome.domain.model.Room(3, "Bathroom", 1),
            )

            val cleanHomeRepository = createCleanHomeRepository()

            cleanHomeDao.deleteAndInsertRooms(roomEntities)

            cleanHomeRepository
                .flowOfAllRooms()
                .test {
                    awaitItem().assertContainsExactlyElementsIn(expectedRooms)
                }
        }
    }
    // TODO: test flowOfAllResidents

    private fun TestScope.createCleanHomeRepository(
        scope: CoroutineScope = this.backgroundScope,
    ) =
        CleanHomeRepositoryImpl(
            scope = scope,
            db = db,
        )

    private fun Task.matchesExpectedTask(expectedTask: Task): Boolean {
        // Cannot validate id in db since it is auto-generated
        return this.name == expectedTask.name &&
                this.room == expectedTask.room &&
                this.duration == expectedTask.duration &&
                this.frequency == expectedTask.frequency &&
                this.scheduledDate == expectedTask.scheduledDate &&
                this.urgency == expectedTask.urgency &&
                this.assigneeId == expectedTask.assigneeId
    }

    private fun task(
        id: Int? = 1,
        name: String = "Vacuum",
        room: com.humanmusik.cleanhome.domain.model.Room = com.humanmusik.cleanhome.domain.model.Room(
            id = 1,
            name = "Living Room",
            homeId = 1,
        ),
        duration: Duration = 30.minutes,
        frequency: Frequency = Frequency.Weekly,
        scheduledDate: LocalDate = LocalDate.of(2026, 7, 7),
        urgency: Urgency = Urgency.Urgent,
        assignedTo: Resident = Resident(
            id = 1,
            name = "John Smith",
            homeId = 1,
        ),
    ) = Task(
        id = id,
        name = name,
        room = room,
        duration = duration,
        frequency = frequency,
        scheduledDate = scheduledDate,
        urgency = urgency,
        assigneeId = assignedTo,
    )

    private fun taskEntity(
        id: Int = 1,
        name: String = "Vacuum",
        room: RoomEntity = RoomEntity(
            id = 1,
            name = "Living Room",
            homeId = 1,
        ),
        duration: Duration = 30.minutes,
        frequency: Frequency = Frequency.Weekly,
        scheduledDate: LocalDate = LocalDate.of(2026, 7, 7),
        urgency: Urgency = Urgency.Urgent,
        assignedTo: ResidentEntity = ResidentEntity(
            id = 1,
            name = "John Smith",
            homeId = 1,
        ),
    ) = TaskEntity(
        id = id,
        name = name,
        room = room,
        duration = duration,
        frequency = frequency,
        scheduledDate = scheduledDate,
        urgency = urgency,
        assignedTo = assignedTo,
    )

    private fun Task.assertExistsInDb(
        tasksInDb: Set<Task>,
        furtherActions: Set<Task>.(Int) -> Unit = {},
    ) {
        tasksInDb
            .apply {
                var taskExistsInDb = false
                var index = 0
                for (task in this@apply) {
                    if (task.matchesExpectedTask(this@assertExistsInDb)) {
                        taskExistsInDb = true
                        break
                    }
                    index++
                }
                taskExistsInDb assertIsEqualTo true

                furtherActions(tasksInDb, index)
            }
    }
}